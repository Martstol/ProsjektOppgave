\section{C++ Wrappers}

PETSc is written in the C programming language and features an object oriented
design pattern, with all the disadvantages and advantages that entails. In order
to write maintainable, high level code that follows C++ idioms, C++ wrapper
classes have been created for the PETSc classes that was used in the
implementation.

The C++ wrappers serve the primary purpose of simplifying coding with PETSc in
C++. This is achieved by putting all the PETSc wrapper functions and classes in
a separate namespace and by utilizing classes and exceptions.

The following C++ classes was created for the project:
\begin{description}
	\item[Vector,] wrapper for Vec
	\item[Matrix,] wrapper for Mat
	\item[KspSolver,] wrapper for KSP
\end{description}

\subsection{Namespace}

Namespace is a tool in C++ for avoiding name collisions. A namespace groups
functions, classes and variables in the global scope into a namespace scope.
All C++ wrapper functions and classes have been put in a namespace called
$petscpp$, for PETSc plus plus, to avoid naming collisions.

\subsection{Rule of Five}

The \emph{Rule of Five} is a rule of thumb in C++ for writing exception and
memory leak safe code introduced in C++11. The Rule of Five describes how 
special member functions for classes should be used to do this. Special member
functions in C++ are functions that the compiler will automatically generate if
they are not implemented by the developer. Before C++11 the Rule of Five was
known as the Rule of Three, it was updated with the introduction of \emph{move
semantics} and \emph{rvalue references} in C++11.

The Rule of Five should be used when a class implements custom behavior for one
of the five following special class member functions.
\begin{itemize}
	\item destructor
	\item copy constructor
	\item move constructor
	\item copy assignment operator
	\item move assignment operator
\end{itemize}
The Rule of Five states that if either one of these functions are implemented by
the developer, then the automatic function generated by the complier does
probably not fit the class' behavior and should be implemented as well.

\subsubsection{Constructor and Destructor}

As the lifetime of the PETSc object is tied to that of the wrapper object,
the class' constructor also calls the PETSc object's Create function and the 
destructor calls the Destroy function. 

\subsubsection{Copy}

A large amount of data is stored in the Vector and Matrix objects used for solving the
Poisson equation, therefore we don't want any accidental copy operations.
The default behavior for the copy constructor and assignment operator has
therefore been deleted.

\subsubsection{Move}

As copying is not allowed, in order for functions to return Vector and Matrix
objects the move constructor and assignment operator has been implemented.
Move semantics was added in C++11 and allows the destination object to take
ownership of the source objects data.

\subsection{Exceptions}

All PETSc functions return and integer error code of the type PetscErrorCode.
This is a typical method for handling errors in C as C does not have direct
support for error handling. C++ on the other hand does offer error handling in
the form of exceptions which has been used to handle errors in the PETSc C++
wrapper library. If an error code different from 0 is returned, an exception
is thrown with the 

In practice many functions in PETSc always returns the value 0, which means that
no error occurred. 
In these cases the extra code made necessary by error checking is not needed.
Because error handling is done internally in the C++ class functions, the
programmer does not have to check if the PETSc function returns an error code
every time the function is used.
